/*----------------------------------------------------------------------------
 *
 *   Copyright (C) 2016-2017 Antonio Augusto Alves Junior
 *
 *   This file is part of Hydra Data Analysis Framework.
 *
 *   Hydra is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   Hydra is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with Hydra.  If not, see <http://www.gnu.org/licenses/>.
 *
 *---------------------------------------------------------------------------*/

/*
 * Chains.h
 *
 *  Created on: 07/10/2017
 *      Author: Antonio Augusto Alves Junior
 */

#ifndef CHAINS_H_
#define CHAINS_H_


#include <utility>
#include <algorithm>
#include <functional>
#include <initializer_list>
#include <cassert>

#include <hydra/detail/Config.h>
#include <hydra/detail/BackendPolicy.h>
#include <hydra/Types.h>
#include <hydra/Containers.h>
#include <hydra/Decays.h>
#include <hydra/detail/utility/Utility_Tuple.h>
#include <hydra/detail/utility/Generic.h>
#include <hydra/detail/functors/FlagAcceptReject.h>
//thrust
#include <hydra/detail/external/thrust/tuple.h>
#include <hydra/detail/external/thrust/iterator/zip_iterator.h>
#include <hydra/detail/external/thrust/distance.h>

namespace hydra {


template<typename ...Decays>
struct Chains;

/**
 * @ingroup phsp
 * @brief Memory storage for a chain of decays.
 *
 * Allocate memory for a chain of decays. Each decay needs be generated by a corresponding instance of hydra::PhaseSpace.
 * @tparam N number of particles in final states of each decay.
 * @tparam BACKEND
 */
template<size_t ...N, hydra::detail::Backend BACKEND>
class Chains< Decays<N,hydra::detail::BackendPolicy<BACKEND> >...>
{


	typedef hydra::detail::BackendPolicy<BACKEND> system_t;

	typedef decltype(hydra::detail::make_index_sequence<sizeof...(N)> { }) indexing_type;

public:

//direct iterators
	typedef HYDRA_EXTERNAL_NS::thrust::tuple<typename
			Decays<N,hydra::detail::BackendPolicy<BACKEND> >::iterator...> iterator_tuple;

	typedef HYDRA_EXTERNAL_NS::thrust::tuple<typename
			Decays<N,hydra::detail::BackendPolicy<BACKEND> >::const_iterator...> const_iterator_tuple;


	//reverse iterators
	typedef HYDRA_EXTERNAL_NS::thrust::tuple<typename
			Decays<N,hydra::detail::BackendPolicy<BACKEND> >::reverse_iterator...> reverse_iterator_tuple;

	typedef HYDRA_EXTERNAL_NS::thrust::tuple<typename
			Decays<N,hydra::detail::BackendPolicy<BACKEND> >::const_reverse_iterator...> const_reverse_iterator_tuple;

	//weights
	typedef typename system_t::template container<GReal_t>  weights_type;
	typedef typename weights_type::iterator iterator_v;
	typedef typename weights_type::const_iterator const_iterator_v;
	typedef typename weights_type::iterator reverse_iterator_v;
	typedef typename weights_type::const_iterator const_reverse_iterator_v;

	//zipped iterators
	typedef HYDRA_EXTERNAL_NS::thrust::zip_iterator<
				 typename detail::tuple_cat_type<
					 HYDRA_EXTERNAL_NS::thrust::tuple<iterator_v>,
					 iterator_tuple
				 >::type
			 >  iterator;

	typedef HYDRA_EXTERNAL_NS::thrust::zip_iterator<
				typename detail::tuple_cat_type<
					HYDRA_EXTERNAL_NS::thrust::tuple<const_iterator_v>,
					const_iterator_tuple
				>::type
			>  const_iterator;

	typedef HYDRA_EXTERNAL_NS::thrust::zip_iterator<
				typename detail::tuple_cat_type<
					HYDRA_EXTERNAL_NS::thrust::tuple<reverse_iterator_v>,
					reverse_iterator_tuple
				>::type
			>  reverse_iterator;

	typedef HYDRA_EXTERNAL_NS::thrust::zip_iterator<
				typename detail::tuple_cat_type<
					HYDRA_EXTERNAL_NS::thrust::tuple<const_reverse_iterator_v>,
					const_reverse_iterator_tuple
				>::type
			>  const_reverse_iterator;


	typedef   typename iterator::value_type value_type;
	typedef   typename iterator::reference  reference;
	typedef   typename iterator::const_reference  const_reference;



	typedef HYDRA_EXTERNAL_NS::thrust::tuple<	Decays<N,hydra::detail::BackendPolicy<BACKEND> >...> decays_type;
	/**
	 * @brief default constructor
	 */
	Chains() = default;

	/**
	 * @brief Constructor allocating memory for a given number of events.
	 * @param nevents number of events
	 */
	Chains(size_t nevents){ resize(n);}

	/**
	 * @brief Copy constructor
	 * @param other chain container defined at same back-end.
	 */
	Chains(Chains<Decays<N,hydra::detail::BackendPolicy<BACKEND> >...>const& other):
		fDecays(other.__copy_decays()),
		fWeights(other.__copy_weights()){}

	/**
	 * @brief Copy constructor
	 * @param other chain container defined in other back-end.
	 */
	template<hydra::detail::Backend BACKEND2>
	Chains(Chains<Decays<N,hydra::detail::BackendPolicy<BACKEND2> >...>const& other)
	{
		this->resize(HYDRA_EXTERNAL_NS::thrust::distance(other.begin(),  other.end()));
		HYDRA_EXTERNAL_NS::thrust::copy(other.begin(),  other.end(), this->begin() );
	}


/**
 *@brief  Move constructor
 * @param other
 */
	Chains(Chains<Decays<N,hydra::detail::BackendPolicy<BACKEND> >...>&& other):
		fDecays(other.__move_decays()),
		fWeights(other.__move_weights())
	{}


/**
 * @brief Assignment operator for chain container allocated in the same back-end
 * @param other
 * @return
 */
	Chains<Decays<N,hydra::detail::BackendPolicy<BACKEND> >...>&
	operator=(Chains<Decays<N,hydra::detail::BackendPolicy<BACKEND> >...> const& other)
	{
		if(this==&other) return *this;
		this->fDecays  = other.__copy_decays();
		this->fWeights = other.__copy_weights();

		return *this;
	}

	/**
	 * @brief Assignment operator for chain container allocated in a different back-end.
	 * @param other
	 * @return
	 */
	template<hydra::detail::Backend BACKEND2>
	Chains<Decays<N,hydra::detail::BackendPolicy<BACKEND> >...>&
	operator=(Chains<Decays<N,hydra::detail::BackendPolicy<BACKEND2> >...>const& other)
	{
		HYDRA_EXTERNAL_NS::thrust::copy(other.begin(),  other.end(), this->begin() );

		return *this;
	}

	/**
	 * @brief Move-assignment operator for chain container allocated in a same back-end.
	 * @param other
	 * @return
	 */
	Chains<Decays<N,hydra::detail::BackendPolicy<BACKEND> >...>&
	operator=(Chains<Decays<N,hydra::detail::BackendPolicy<BACKEND> >...>&& other)
	{
		if(this==&other) return *this;
		this->fDecays  = other.__move_decays();
		this->fWeights = other.__move_weights();
		return *this;
	}
	/**
	 * @brief Constructor from a list of decay containers.
	 * @param events
	 */
	Chains(Decays<N,hydra::detail::BackendPolicy<BACKEND> > const& ...events);



	GenericRange<iterator_v >
	GetWeights() {
		return hydra::make_range(this->fWeights.begin(), this->fWeights.end());
	}

	GenericRange<const_iterator_v >
	GetWeights() const {
		return hydra::make_range(this->fWeights.begin(), this->fWeights.end());
	}

	template<unsigned int I>
	GenericRange< typename HYDRA_EXTERNAL_NS::thrust::tuple_element<I, decays_type >::type::iterator>
	GetDecays(placeholders::placeholder<I> const& p) {
			return hydra::make_range(HYDRA_EXTERNAL_NS::thrust::get<I>(this->fDecays).begin(),
					HYDRA_EXTERNAL_NS::thrust::get<I>(this->fDecays).end());
		}

	template<unsigned int I>
	GenericRange< typename HYDRA_EXTERNAL_NS::thrust::tuple_element<I, decays_type >::type::const_iterator>
	GetDecays(placeholders::placeholder<I> const& p) const {
		return hydra::make_range(HYDRA_EXTERNAL_NS::thrust::get<I>(this->fDecays).begin(),
				HYDRA_EXTERNAL_NS::thrust::get<I>(this->fDecays).end());
	}

	/**
	 * @brief Iterator to begin of container range.
	 * @return iterator
	 */
	iterator begin(){ return fBegin; }

	/**
	 * @brief Iterator to end of container range.
	 * @return iterator
	 */
	iterator  end(){ return fEnd; }

	/*
	 * constant access iterators
	 */
	const_iterator  begin() const{ return fConstBegin; }
	const_iterator    end() const{ return fConstEnd; }
	const_iterator cbegin() const{ return fConstBegin; }
	const_iterator   cend() const{ return fConstEnd; }

	/**
	 * @brief  Iterator to begin of decay container range.
	 * @return
	 */
	template<unsigned int I>
	iterator begin(){ return HYDRA_EXTERNAL_NS::thrust::get<I>(fStorage).begin(); }

	/**
	 * @brief  Iterator to end of decay container range.
	 * @return
	 */
	template<unsigned int I>
	iterator  end(){ return HYDRA_EXTERNAL_NS::thrust::get<I>(fStorage).end() ; }

	/*
	 * constant access iterators
	 */
	template<unsigned int I>
	const_iterator begin() const{ return HYDRA_EXTERNAL_NS::thrust::get<I>(fStorage).cbegin() ; }

	template<unsigned int I>
	const_iterator  end() const{ return HYDRA_EXTERNAL_NS::thrust::get<I>(fStorage).cend() ; }

	template<unsigned int I>
	const_iterator cbegin() const{ return HYDRA_EXTERNAL_NS::thrust::get<I>(fStorage).cbegin() ; }

	template<unsigned int I>
	const_iterator  cend() const{ return HYDRA_EXTERNAL_NS::thrust::get<I>(fStorage).cend() ; }

	/**
	 * @brief capacity.
	 * @return capacity in number of elements
	 */
	size_t capacity() const  { return fFlags.capacity(); }

	/**
	 * @brief resize container to N.
	 */
	void resize(size_t n);

	/**
	 * @brief size of the container in number of elements.
	 * @return
	 */
	size_t size() const { return fSize; }

	/**
	 * @brief subscript operator.
	 * @param i
	 * @return reference to chain i
	 */
	reference_type operator[](size_t i)
	{ return fBegin[i];	}


	const reference_type operator[](size_t i) const
	{ return fConstBegin[i]; }

	event_tuple const& CopyStorage() const { return fStorage;}


private:

	event_tuple MoveStorage(){ return std::move(fStorage);}

	size_t	CheckSizes(std::initializer_list<size_t> sizes)
	{
		assert(std::adjacent_find( sizes.begin(), sizes.end(),
				std::not_equal_to<size_t>() ) == sizes.end());
		size_t s=*sizes.begin();
		return	s;
	}

	decays_type  fDecays;
	weights_type fWeights;


};

template<size_t ...N,hydra::detail::Backend BACKEND >
Chains< Decays<N, hydra::detail::BackendPolicy<BACKEND> >...>
make_chain( hydra::detail::BackendPolicy<BACKEND> const& policy, size_t entries )
{
	return std::move( Chains<Decays<N, hydra::detail::BackendPolicy<BACKEND> >...>(entries) );
}


template<size_t I, hydra::detail::Backend BACKEND, size_t ...N>
auto get_decay(Chains<Decays<N, hydra::detail::BackendPolicy<BACKEND> >...>& chain )
-> typename HYDRA_EXTERNAL_NS::thrust::tuple_element<I,
      typename Chains<Decays<N, hydra::detail::BackendPolicy<BACKEND> >...>::event_tuple>::type&
{
	return chain.template GetDecay<I>();
}


}  // namespace hydra

#include <hydra/detail/Chains.inl>




#endif /* CHAINS_H_ */
